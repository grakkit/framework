const nms=eval(`Packages.net.minecraft.server.${server.getClass().getCanonicalName().split(".")[3]}`),UUID=Java.type("java.util.UUID"),Runnable=Java.extend(Java.type("java.lang.Runnable")),ArrayList=Java.type("java.util.ArrayList"),NBTTagList=nms.NBTTagList,SecureRandom=Java.type("java.security.SecureRandom"),NBTTagCompound=nms.NBTTagCompound,NBTTagIntArray=nms.NBTTagIntArray,NBTTagByteArray=nms.NBTTagByteArray,tasks=[],crypto=new SecureRandom,_={access:object=>{if(null===object||"object"!=typeof object)return object;{const output={_:object};Object.entries(object).forEach(entry=>{"[foreign HostFunction]"===toString.apply(entry[1])?Object.defineProperty(output,entry[0],{get(){const output=(...args)=>_.access(entry[1](...args));return output.hostFunction=entry[0],output}}):Object.defineProperty(output,entry[0],{get:()=>_.access(entry[1])});let index=void 0;if(entry[0].startsWith("is")&&entry[0][2]&&(index=2),entry[0].startsWith("get")&&entry[0][3]&&(index=3),index){let key=entry[0].slice(index);if(key.length){let camel=key[0].toLowerCase()+key.slice(1);if(!Object.keys(object).includes(camel))try{entry[1](),Object.defineProperty(output,camel,{get:()=>_.access(entry[1]()),set:value=>object[`set${key}`]&&object[`set${key}`](value)})}catch(error){}}}});const array=_.array(object);return Object.keys(array).forEach(index=>{Object.keys(output).includes(index)||Object.defineProperty(output,index,{get:()=>_.access(array[index])})}),output}},array:object=>{const output=[];if("number"==typeof object.length){if(object.length>0){let index=0;for(;output.length<object.length;)output.push(object[index++])}}else"function"==typeof object.forEach?object.forEach(entry=>{output.push(entry)}):"function"==typeof object.forEachRemaining&&object.forEachRemaining(entry=>{output.push(entry)});return output},base:{characters:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",encode:string=>{let index=0,result="";for(;index<string.length;){let a=string.charCodeAt(index++)||0,b=string.charCodeAt(index++)||0,c=string.charCodeAt(index++)||0,d=(15&b)<<2|c>>6&3,e=63&c;b?c||(e=64):d=e=64,result+=_.base.characters.charAt(a>>2&63),result+=_.base.characters.charAt((3&a)<<4|b>>4&15),result+=_.base.characters.charAt(d),result+=_.base.characters.charAt(e)}return result},decode:string=>{let index=0,result="";for(;index<string.length;){let a=_.base.characters.indexOf(string.charAt(index++)),b=_.base.characters.indexOf(string.charAt(index++)),c=_.base.characters.indexOf(string.charAt(index++)),d,e=(15&b)<<4|c>>2&15,f=(3&c)<<6|63&_.base.characters.indexOf(string.charAt(index++));result+=String.fromCharCode((63&a)<<2|b>>4&3),result+=e?String.fromCharCode(e):"",result+=f?String.fromCharCode(f):""}return result}},camel:(string,separator)=>{const pascal=_.pascal(string,separator);return _.lower(pascal[0])+pascal.slice(1)},clamp:(number,min,max)=>number<min?min:number>max?max:number,collect:(...array)=>{const output=new ArrayList;return array.forEach(entry=>{output.add(entry)}),output},color:string=>string.replace(/(&)/g,"§").replace(/(§§)/g,"&"),define:(object,consumer)=>{consumer||(consumer=entry=>({get:()=>entry.value,set:value=>{entry.value=value}}));const output={};return _.entries(object).forEach(entry=>{const info=consumer(entry);info&&Object.defineProperty(output,entry.key,{get(){if(info.get)return info.get()},set(value){info.set&&info.set(value)}})}),output},dist:(source,target,flat)=>{if(source.getWorld()!==target.getWorld())return 1/0;var deltaX=source.getX()-target.getX(),deltaY=flat?0:source.getY()-target.getY(),deltaZ=source.getZ()-target.getZ();return Math.sqrt(deltaX*deltaX+deltaY*deltaY+deltaZ*deltaZ)},entries:object=>_.keys(object).map(key=>({key:key,value:object[key]})),extend:(object,...objects)=>Object.assign(object,...objects),flat:array=>array.filter(entry=>entry),interval:(script,period)=>{const state={iteration:null},loop=()=>{try{script()}catch(error){console.error(error)}state.iteration=_.timeout(loop,period)};state.iteration=_.timeout(loop,period);const output={cancel:()=>state.iteration.cancel()};return tasks.push(output),output},key:(object,value)=>_.keys(object)[_.values(object).indexOf(value)],keys:object=>Object.keys(object),lower:string=>string.toLowerCase(),match:(object,filter)=>{switch(typeof filter){case"undefined":return!0;case"function":return filter(object);case"object":switch(_.type(filter)){case"Array":return filter.map(entry=>_.match(object,entry)).includes(!0);case"Object":return!_.keys(filter).map(key=>_.match(object[key],filter[key])).includes(!1);default:return object===filter}default:return object===filter}},mirror:options=>{options||(options={});const mirror=_.extend(options.array||[],{add:options.add||(()=>{}),remove:options.remove||(()=>{}),clear:options.clear||(()=>{})});return{get:()=>mirror,set:value=>{mirror.clear(),value.forEach(mirror.add)}}},nms:nms,object:(array,consumer)=>(consumer||(consumer=(entry,index)=>({[entry.key||index]:entry.value||entry})),_.extend({},..._.flat(array.map(consumer)))),parse:data=>{console.log(core.output(data.value));try{switch(data.type){case"None":return data.value;case"Int":case"Float":case"Double":case"Long":case"Short":case"Byte":case"String":const temp=new NBTTagCompound;return temp[`set${data.type}`]("x",data.value),temp.get("x");case"End":return null;case"List":const list=new NBTTagList;data.value.forEach(entry=>list.add(_.parse(entry)));case"ByteArray":const bytes=new NBTTagByteArray(_.collect());return data.value.forEach(entry=>bytes.add(_.parse(entry))),bytes;case"IntArray":const ints=new NBTTagIntArray(_.collect());return data.value.forEach(entry=>ints.add(_.parse(entry))),ints;case"Compound":const compound=new NBTTagCompound;return _.entries(data.value).forEach(entry=>compound.set(entry.key,_.parse(entry.value))),compound}}catch(error){global.test=data,console.log(error.stack)}},pascal:(string,separator)=>separator?string.split(separator).map(chunk=>_.pascal(chunk)).join(""):_.upper(string[0])+string.slice(1),player:target=>{let uuid=void 0;const players=Object.assign({},core.data("grakkit/players"));if(target instanceof UUID)uuid=target;else if("string"==typeof target){const online=server.getPlayer(target);if(players[target])uuid=_.uuid(players[target].uuid);else if(online)uuid=online.getUniqueId();else if(_.array(server.getOfflinePlayers()).forEach(offline=>{const stored=offline.getUniqueId();void 0===uuid&&[stored.toString(),offline.getName()].includes(target)&&(uuid=stored)}),void 0===uuid)try{uuid=_.uuid(target)}catch(error){uuid=server.getOfflinePlayer(target).getUniqueId()}}else if("string"==typeof target.uuid)uuid=_.uuid(target.uuid);else if("function"==typeof target.uuid)uuid=_.uuid(target.uuid());else{if("function"!=typeof target.getUniqueId){if(target.constructor===Array)return target.map(_.player);throw`FrameworkError: Cannot convert ${core.output(target)} to standardized player notation!`}uuid=target.getUniqueId()}return Object.assign(players[uuid.toString()]||{uuid:uuid.toString()},{online:server.getPlayer(uuid),offline:server.getOfflinePlayer(uuid)})},rand:(...args)=>{switch(args.length){case 0:return(crypto.nextInt()+2147483648)/4294967296;case 1:return"number"==typeof args[0]?_.rand()<args[0]:args[0].length?args[0][_.rand(0,args[0].length-1)]:_.rand(_.keys(args[0]));case 2:return Math.floor(_.rand()*(args[1]-args[0]+1))+args[0]}},raw:string=>string.replace(/(&)/g,"&&").replace(/(§)/g,"&"),serialize:data=>{if([null,void 0].includes(data))return{type:"None",value:data};{let value=void 0;const type=data.getClass().getCanonicalName().split("NBTTag")[1];switch(type){case"Int":case"Float":case"Double":case"Long":case"Short":case"Byte":case"String":value=data[`as${type}`]();break;case"End":value=null;break;case"List":case"ByteArray":case"IntArray":value=_.array(data).map(_.serialize);break;case"Compound":value=_.object(_.array(data.map.entrySet()),entry=>({[entry.getKey()]:_.serialize(entry.getValue())}))}return{type:type,value:value}}},simplify:(...context)=>{let output=null;const object=context[0];switch(_.type(object)){case"Array":output=[];for(let entry of object)context.includes(entry)||output.push(_.simplify(entry,...context));output=_.flat(output),output.length||(output=null);break;case"Object":output={};for(let key of _.keys(object))context.includes(object[key])||(output[key]=_.simplify(object[key],...context));output=_.strain(output),_.keys(output).length||(output=null);break;default:output=object}return output},splice:(string,separator,...index)=>string.split(separator).slice(...index).join(separator),strain:(object,consumer)=>(consumer||(consumer=entry=>entry.value),_.object(_.entries(object).filter(consumer))),timeout:(script,period)=>{const state={cancel:!1},runnable=new Runnable({run:()=>state.cancel||script()});server.getScheduler().runTaskLater(core.plugin,runnable,Math.ceil(period/50));const output={cancel:()=>state.cancel=!0};return tasks.push(output),output},type:object=>{const type=toString.apply(object).split(" ")[1].slice(0,-1);return"Object"===type?object.constructor.name:type},upper:string=>string.toUpperCase(),uuid:string=>string?UUID.fromString(string):UUID.randomUUID(),values:object=>Object.values(object)};core.event("org.bukkit.event.player.PlayerJoinEvent",event=>{const player=event.getPlayer(),address=player.getAddress().getAddress().getHostAddress(),name=player.getName(),uuid=player.getUniqueId().toString(),info={address:address,name:name,uuid:uuid};Object.assign(core.data("grakkit/players"),{[address]:info,[name]:info,[uuid]:info})}),core.event("org.bukkit.event.server.PluginDisableEvent",event=>{event.getPlugin()===core.plugin&&tasks.forEach(task=>task.cancel())}),core.export(_);